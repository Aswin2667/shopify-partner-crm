services:
  client:
    container_name: client
    build:
      context: .
      dockerfile: ./apps/client/Dockerfile
    environment:
      VITE_FRONTEND_PORT: ${VITE_FRONTEND_PORT}
      VITE_CLIENT_ID: ${VITE_CLIENT_ID}
      VITE_TOKEN_SECRET_KEY: ${VITE_TOKEN_SECRET_KEY}
      
    restart: always
    ports:
      - 3000:3000
    networks:
      - app_network
    # depends_on:
    #   - server
  
  # server:
  #   container_name: server
  #   build:
  #     context: .
  #     dockerfile: ./apps/server/Dockerfile
  #   restart: always
  #   networks:
  #     - app_network
  #   ports:
  #     - 8080:8080
  #   environment:
  #     VITE_FRONTEND_PORT: ${VITE_FRONTEND_PORT}
  #     VITE_CLIENT_ID: ${VITE_CLIENT_ID}
  #     GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID}
  #     GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET}
  #     VITE_TOKEN_SECRET_KEY: ${VITE_TOKEN_SECRET_KEY}
  #     BACKEND_PORT: ${BACKEND_PORT}

  # tracker:
  #   container_name: tracker
  #   build:
  #     context: .
  #     dockerfile: ./apps/tracker/Dockerfile
  #   restart: always
  #   ports:
  #     - 9090:9090
  #   networks:
  #     - app_network
  #   depends_on:
  #     - redis
  #     - s3
  #     - zipkin
  
  # scheduler:
  #   container_name: scheduler
  #   build:
  #     context: .
  #     dockerfile: ./apps/scheduler/Dockerfile
  #   restart: always
  #   ports:
  #     - 8081:8081
  #   networks:
  #     - app_network
  #   depends_on:
  #     - redis
  #     - s3
  #     - zipkin
  
  # event-consumer:
  #   container_name: event-consumer
  #   build:
  #     context: .
  #     dockerfile: ./apps/event-consumer/Dockerfile
  #   restart: always
  #   ports:
  #     - 8082:8082
  #   networks:
  #     - app_network
  #   depends_on:
  #     - redis
  #     - s3
  #     - zipkin

  # redis:
  #   image: redis
  #   container_name: ${REDIS_CONTAINER_NAME:-redis}
  #   ports:
  #     - "${REDIS_PORT:-6379}:6379"
  #   networks:
  #     - app_network
  #   volumes:
  #     - redis_volume_data:/data
  #   healthcheck:
  #     test: ["CMD", "redis-cli", "ping"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #   restart: always 

  # postgres:
  #   image: ${POSTGRES_IMAGE:-postgres:latest}
  #   hostname: ${POSTGRES_HOSTNAME:-postgres}
  #   container_name: ${POSTGRES_CONTAINER_NAME:-postgres_db}
  #   environment:
  #     POSTGRES_USER: ${POSTGRES_USER:-postgres}
  #     POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
  #   ports:
  #     - "${POSTGRES_PORT:-5432}:5432"
  #   networks:
  #     - app_network
  #   healthcheck:
  #     test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 5
  #   restart: always
  #   volumes:
  #     - postgres_data:/var/lib/postgresql/data


  # s3:
  #   image: quay.io/minio/minio
  #   command: "server /data --console-address :9123"
  #   ports:
  #     - "9123:9123"
  #     - "9001:9000"
  #   healthcheck:
  #     test: ["CMD", "mc", "ready", "local"]
  #     interval: 5s
  #     timeout: 5s
  #     retries: 5
  #   environment:
  #     MINIO_ROOT_USER: test
  #     MINIO_ROOT_PASSWORD: 12345678
  #   container_name: s3
  #   networks:
  #     - app_network
  #   restart: always 

  # zipkin:
  #   build:
  #     context: .
  #     dockerfile: ./zipkin/Dockerfile
  #   container_name: zipkin
  #   networks:
  #     - app_network
  #   restart: always
  #   environment:
  #     - STORAGE_TYPE=mem
  #     - SELF_TRACING_ENABLED=true
  #     - JAVA_OPTS=-Xms128m -Xmx128m -XX:+ExitOnOutOfMemoryError
  #   ports:
  #      - 9411:9411
  #   command: --logging.level.zipkin2=DEBUG

volumes:
  redis_insight_volume_data:
  redis_volume_data:
  pgadmin-data:
  postgres_data:

networks:
  app_network:
    driver: bridge